---
- name: Set ansible user for role
  set_fact:
    ansible_ssh_user: "{{ windows_domain_controller_info.domain_admin_user }}"
    ansible_ssh_pass: "{{ windows_domain_controller_info.domain_admin_password }}"

- name: Stage CAPolicy.inf
  template: 
    src: ../template/capolicy.inf.j2
    dest: c:\windows\CAPolicy.inf

- name: Create PKI Virtual Directory
  win_shell: |
    $path = "c:\pki"
    $share = Get-SmbShare -Name "pki" -ErrorAction SilentlyContinue

    # remove share if exists
    if($share -ne $null){
        write-output "Removing existing share"
        Remove-SmbShare -Name "pki" -Force
    }

    # remove directory if exists
    if([System.IO.Directory]::Exists($path)){
        write-output "Removing existing directory"
        Remove-Item $path -Recurse -Force
    }

    # create directory and share
    New-item -path $path â€“type directory
    Write-Output "Example CPS statement" | Out-File $path\cps.txt
    New-SMBShare -Name pki $path -FullAccess SYSTEM,"{{ windows_domain_controller_info['domain_netbios_name'] }}\Domain Admins" -ChangeAccess "{{ windows_domain_controller_info['domain_netbios_name'] }}\Cert Publishers"

- name: Install ADCS with sub features and management tools
  win_feature:
    name: 
      - Adcs-Cert-Authority
      - Adcs-Enroll-Web-Pol
    state: present
    include_management_tools: yes
  register: windows_adcs

- name: Reboot if installing Adcs-Cert-Authority feature requires it
  win_reboot:
    shutdown_timeout: 600
    reboot_timeout: 600
    post_reboot_delay: 300
  when: windows_adcs.reboot_required

- name: Add PSGallery as Trusted Powershell Repo
  win_shell: |
    if ($false -eq (get-packagesource | Where-Object { $_.Name -eq "PSGallery" } | % { $_.istrusted })){ 
      Set-PackageSource -Name PSGallery -Trusted -Force 
    }

# Add powershell modules
- name: Check for xDnsServer Powershell module
  win_shell: |
    Install-Module -Name xDnsServer

# add pki dns cname
- name: Configure pki CNAME
  win_dsc:
    resource_name: xDnsRecord
    Name: "pki"
    Zone: "{{ windows_domain_controller_info['dns_domain_name'] }}"
    Target: "{{ groups['domain_controller'][0].split('.')[0] | lower }}.{{ windows_domain_controller_info['dns_domain_name'] }}"
    Type: CName

# add iis virtual directory
- name: Add PKI Virtual Directory
  win_shell: |
    Import-Module WebAdministration
    $FolderPath = "c:\pki"
    New-WebVirtualDirectory -Site "Default Web Site" -Name "pki" -PhysicalPath $FolderPath
    $apppoolsid = (Get-ItemProperty IIS:\AppPools\DefaultAppPool).applicationPoolSid
    $acl = Get-Acl $FolderPath
    $colRights = [System.Security.AccessControl.FileSystemRights]"Read,ExecuteFile,ListDirectory"
    $permission = "IIS AppPool\DefaultAppPool",$colRights,"ContainerInherit,ObjectInherit","None","Allow"
    $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission  
    $acl.AddAccessRule($accessRule) 
    $acl | Set-Acl $FolderPath

- name: Add ActiveDirectoryCSDsc
  win_shell: |
    Install-Module -Name ActiveDirectoryCSDsc

- name: Configure ActiveDirectoryCSDsc Powershell DSC
  win_dsc:
    resource_name: DSC_AdcsCertificationAuthority
    IsSingleInstance: 'Yes'
    CAType: 'EnterpriseRootCA'
    CryptoProviderName: 'RSA#Microsoft Software Key Storage Provider'
    CACommonName: "{{ windows_certificate_authority_info['CACommonName'] }}"
    Ensure: 'Present'
    KeyLength: "{{ windows_certificate_authority_info['KeyLength'] }}"
    HashAlgorithmName: "{{ windows_certificate_authority_info['HashAlgorithmName'] }}"
    ValidityPeriod: "{{ windows_certificate_authority_info['ValidityPeriod'] }}"
    ValidityPeriodUnits: "{{ windows_certificate_authority_info['ValidityPeriodUnits'] }}"
    PsDscRunAsCredential_username: "{{ windows_domain_controller_info['domain_admin_user'] }}"
    PsDscRunAsCredential_password: "{{ windows_domain_controller_info['domain_admin_password'] }}"
    Credential_username: "{{ windows_domain_controller_info['domain_admin_user'] }}"
    Credential_password: "{{ windows_domain_controller_info['domain_admin_password'] }}"

# add crl extension
- name: Add CRL Extension
  win_shell: |
    $crllist = Get-CACrlDistributionPoint; 
    foreach ($crl in $crllist) {
      Remove-CACrlDistributionPoint $crl.uri -Force
    }; 
    Add-CACRLDistributionPoint -Uri C:\Windows\System32\CertSrv\CertEnroll%3%8%9.crl -PublishToServer -PublishDeltaToServer -Force
    Add-CACRLDistributionPoint -Uri http://pki.{{ windows_domain_controller_info['dns_domain_name'] }}/pki/%3%8%9.crl -AddToCertificateCDP -Force
    Add-CACRLDistributionPoint -Uri file://\\pki.{{ windows_domain_controller_info['dns_domain_name'] }}\pki\%3%8%9.crl -PublishToServer -PublishDeltaToServer -Force
    restart-service certsvc

- name: Add AIA Extension
  win_shell: |
    $aialist = Get-CAAuthorityInformationAccess; 
    foreach ($aia in $aialist) {
      Remove-CAAuthorityInformationAccess $aia.uri -Force
    }; 
    Add-CAAuthorityInformationAccess -AddToCertificateAia http://pki.{{ windows_domain_controller_info['dns_domain_name'] }}/pki/%1_%3%4.crt -Force
    restart-service certsvc 

- name: Copy crt and crl to pki directory
  win_shell: |
    Copy-Item C:\Windows\system32\certsrv\certenroll\*.cr* \\localhost\pki

- name: Configure Client-Server Authentication and IAS RAS Server Templates for Autoenroll
  win_shell: |
    Function Get-RandomHex {
    param ([int]$Length)
        $Hex = '0123456789ABCDEF'
        [string]$Return = $null
        For ($i=1;$i -le $length;$i++) {
            $Return += $Hex.Substring((Get-Random -Minimum 0 -Maximum 16),1)
        }
        Return $Return
    }

    Function IsUniqueOID {
    param ($CN,$OID,$ConfigContext)
        $OID_Check = [ADSI]"LDAP://CN=OID,CN=Public Key Services,CN=Services,$ConfigContext"
        if( $($OID_Check.psbase.children | where { $_.cn -eq $Name -and $_.'msPKI-Cert-Template-OID' -eq $msPKICertTemplateOID }).Count -gt 0 ){
            return $false
        }else{
            return $true
        }
    }

    Function New-TemplateOID {
        param ($ConfigContext)
        do {
            $ADSI_OID = [ADSI]"LDAP://CN=OID,CN=Public Key Services,CN=Services,$ConfigContext" 
            $OID_Forest = $ADSI_OID.'msPKI-Cert-Template-OID'

            $OID_Part_1 = Get-Random -Minimum 1000000  -Maximum 99999999
            $OID_Part_2 = Get-Random -Minimum 10000000 -Maximum 99999999
            $OID_Part_3 = Get-RandomHex -Length 32
            $Name = "$OID_Part_2.$OID_Part_3"
            $msPKICertTemplateOID = "$OID_Forest.$OID_Part_1.$OID_Part_2"
        } until (IsUniqueOID -CN $Name -OID $msPKICertTemplateOID -ConfigContext $ConfigContext)
        Return @{
            TemplateOID  = $msPKICertTemplateOID
            TemplateName = $Name
        }
    }

    Function Add-TemplateAcl{
    param($Template, $User, $Read, $Enroll, $AutoEnroll)
        # add domain computers to object security
        $objUser = New-Object System.Security.Principal.NTAccount($User)

        $EnrollObjectType = [GUID]'0e10c968-78fb-11d2-90d4-00c04f79dc55'
        $AutoEnrollObjectType = [GUID]'a05b8cc2-17bc-4802-a710-e7c15ab866a2'
        $GenericRead = [System.DirectoryServices.ActiveDirectoryRights] "GenericRead"
        $InheritedObjectType = [GUID]'00000000-0000-0000-0000-000000000000'
        $Type = [System.Security.AccessControl.AccessControlType]"Allow"
        $aceEnroll  = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $objUser, 'ExtendedRight', $Type, $EnrollObjectType, 'None', $InheritedObjectType
        $aceAutoEnroll  = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $objUser, 'ExtendedRight', $Type, $AutoEnrollObjectType, 'None', $InheritedObjectType
        $aceRead  = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $objUser, $GenericRead, $Type, $InheritedObjectType
        
        if($Enroll) { $Template.ObjectSecurity.AddAccessRule($aceEnroll) }
        if($AutoEnroll) { $Template.ObjectSecurity.AddAccessRule($aceAutoEnroll) }
        if($Read) { $Template.ObjectSecurity.AddAccessRule($aceRead) }

        $Template.commitchanges()

        return @{
            Template = $Template
        }
    }

    Function Copy-Template{
    param($NewTemplateName, $SourceTemplateName, $ConfigContext)
        $ADSI = [ADSI]"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$ConfigContext"
        $st = $ADSI.psbase.children | where {$_.displayName -eq $SourceTemplateName}

        # build new template
        $oid = New-TemplateOID -ConfigContext $ConfigContext
        $t = $ADSI.Create("pKICertificateTemplate", ("CN={0}" -f $oid.TemplateName)) 
        $t.put("distinguishedName",("CN={0},CN=Certificate Templates,CN=Public Key Services,CN=Services,{1}" -f $oid.TemplateName,$ConfigContext)) 
                
        # set configuration values
        $t.put("flags","131680")
        $t.put("displayName",$NewTemplateName)
        $t.put("revision","100")
        $t.put("pKIDefaultKeySpec","1")
        $t.SetInfo()

        $t.put("pKIMaxIssuingDepth","0")
        $t.put("pKIDefaultCSPs","1,Microsoft RSA SChannel Cryptographic Provider")
        $t.put("msPKI-RA-Signature","0")
        $t.put("msPKI-Minimal-Key-Size","2048")
        $t.put("msPKI-Template-Schema-Version","2")
        $t.put("msPKI-Template-Minor-Revision","0")
        $t.put("msPKI-Cert-Template-OID",$oid.TemplateOID)
        $t.putex(3,"msPKI-Certificate-Application-Policy",@("1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2"))
        $t.SetInfo()

        # set inheritence on the template
        $t.ObjectSecurity.SetAccessRuleProtection($st.ObjectSecurity.AreAccessRulesProtected, $false)

        # copy default permission from original policy
        $t.ObjectSecurity.Access | % {
            $t.ObjectSecurity.RemoveAccessRule($_)
        }
        $t.commitchanges()

        $st.ObjectSecurity.Access | % {
            $t.ObjectSecurity.AddAccessRule($_)
        }
        $t.commitchanges()

        # copy properties from template
        $t.pKIKeyUsage = $st.pKIKeyUsage
        $t.pKIExpirationPeriod = $st.pKIExpirationPeriod
        $t.pKIOverlapPeriod = $st.pKIOverlapPeriod
        $t.SetInfo()

        return @{
            Template = $t
        }
    }

    Function Publish-Template{
    param($Template, $ConfigContext)
        $Enrollment_ADSI = [ADSI]"LDAP://CN=Enrollment Services,CN=Public Key Services,CN=Services,$ConfigContext"
        $Enrollment_ADSI.psbase.children | % { 
            $_.putex(3,'certificateTemplates',@($Template.Name))
            $_.commitchanges()
        }
    }

    Function New-WorkstationAuthenticationTemplate{
    param($DisplayName,$ConfigContext)
        $t = Copy-Template -NewTemplateName $DisplayName -SourceTemplateName "Workstation Authentication" -ConfigContext $ConfigContext
        $t.Template.put("pKICriticalExtensions","2.5.29.15")
        $t.Template.putex(3,"pKIExtendedKeyUsage",@("1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2"))
        $t.Template.put("msPKI-Enrollment-Flag","32")
        $t.Template.put("msPKI-Private-Key-Flag","67371264")
        $t.Template.put("msPKI-Certificate-Name-Flag","-2013265920")
        $t.Template.SetInfo()
        $t = Add-TemplateAcl -Template $t.Template -User "Domain Computers" -Read $true -Enroll $true -AutoEnroll $true
        Publish-Template -Template $t.Template -ConfigContext $ConfigContext
    }

    Function New-RASAndIASServerTemplate{
    param($DisplayName, $ConfigContext)
        $t = Copy-Template -NewTemplateName $DisplayName -SourceTemplateName "RAS and IAS Server" -ConfigContext $ConfigContext

        $t.Template.put("pKICriticalExtensions","2.5.29.15")
        $t.Template.putex(3,"pKIExtendedKeyUsage",@("1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2"))
        $t.Template.put("msPKI-Enrollment-Flag","32")
        $t.Template.put("msPKI-Private-Key-Flag","0")
        $t.Template.put("msPKI-Certificate-Name-Flag","-2013265920")
        $t.Template.SetInfo()
        $t = Add-TemplateAcl -Template $t.Template -User "RAS and IAS Servers" -Read $true -Enroll $true -AutoEnroll $true
        Publish-Template -Template $t.Template -ConfigContext $ConfigContext
    }

    Function New-WebServerTemplate{
    param($DisplayName, $ConfigContext)
        $t = Copy-Template -NewTemplateName $DisplayName -SourceTemplateName "Web Server" -ConfigContext $ConfigContext
        
        $t.Template.putex(3,"pKICriticalExtensions",@("2.5.29.7","2.5.29.15"))
        $t.Template.putex(3,"pKIExtendedKeyUsage",@("1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2"))
        $t.Template.put("msPKI-Enrollment-Flag","0")
        $t.Template.put("msPKI-Private-Key-Flag","16842752")
        $t.Template.put("msPKI-Certificate-Name-Flag","1")
        $t.Template.SetInfo()
        Publish-Template -Template $t.Template -ConfigContext $ConfigContext
    }

    $ConfigContext = ([ADSI]"LDAP://RootDSE").ConfigurationNamingContext 
    New-WorkstationAuthenticationTemplate -DisplayName "Client-Server Authentication Policy" -ConfigContext $ConfigContext
    New-RASAndIASServerTemplate -DisplayName "RAS and IAS Server Policy" -ConfigContext $ConfigContext
    New-WebServerTemplate -DisplayName "Web Server Policy" -ConfigContext $ConfigContext
    restart-service certsvc